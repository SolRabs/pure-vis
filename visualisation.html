<!DOCTYPE html>
<meta charset="utf-8" />
<title>Graph Visualization</title>
<style>
  body {
    margin: 50px;
    font-family: Arial;
  }

  h2 {
    clear: both;
  }

  svg {
    float: left;
    border: 1px solid black;
    margin-bottom: 20px;
  }

  div {
    height: 300px;
    width: 1200px;
    overflow: scroll;
  }
</style>

<body>
  <script src="https://d3js.org/d3-array.v2.min.js"></script>
  <script src="https://d3js.org/d3.v5.js"></script>
  <div id="vis"></div>

  <script>
    "use strict";
    async function loadData() {
      const session = await d3.csv("data/test.csv");
      //const session = await d3.csv("data/session-long.csv");
      //const session = await d3.csv("data/session-all-patterns.csv");
      //const session = await d3.csv("data/two-subfields.csv");
      return session;
    }

    async function main() {
      let session = await loadData();

      //Zeit umrechnen in Sekunden seit Start
      session.map(
        (event) =>
          (event.date =
            parseInt(event.date.split(":")[0] * 60 * 60) +
            parseInt(event.date.split(":")[1] * 60) +
            parseInt(event.date.split(":")[2]))
      );
      let start = session[0].date;
      session.map((event) => (event.date = event.date - start));

      let actionevents = [
        "Pub qd for selected",
        "Pub imported",
        "Pub excluded",
        "Pub activated",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
      ];
      removeDoubleFilterEvents(session);
      let unfilteredActionEvents = session.filter((event) =>
        actionevents.includes(event.event)
      );

      let width = window.innerWidth * 0.9;
      let height = window.innerHeight * 0.9;
      let statusHeight = 100;
      let pubLineHeight = 20;
      let topPadding = 10;
      let patternLineHeight = 0;
      let actionLineHeight = topPadding + 90 + statusHeight + patternLineHeight;
      let legendPadding = 130;

      function mouseout(mouseData) {
        svg.select("#tooltip").remove();
      }

      function mouseover(mouseData) {
        console.log(mouseData);
        svg.append("g").attr("id", "tooltip");
        let tooltipX = event.pageX;
        let tooltipY = event.pageY;
        d3.select("#tooltip")
          .append("rect")
          .attr("x", tooltipX)
          .attr("y", tooltipY)
          .attr("width", 200)
          .attr("height", 30)
          .attr("fill", "white")
          .attr("stroke", "black");
        d3.select("#tooltip")
          .append("text")
          .attr("x", tooltipX + 10)
          .attr("y", tooltipY + 20)
          .attr("stroke", "black")
          .text(mouseData);
      }

      //Überflüssige Filterevents (Teilworte) entfernen.
      function removeDoubleFilterEvents(session, startindex = 0) {
        //Erster Buchstabe des Filters finden
        let firstFilterEvent = session.find(
          (event) =>
            event.event == "Filter updated" &&
            session.findIndex((current) => current == event) > startindex
        );

        if (firstFilterEvent) {
          let firstIndex = session.findIndex(
            (event) => event == firstFilterEvent
          );

          let firstRealEvent = session.find(
            (event, index) =>
              event.event != "Filter updated" &&
              event.event != "Pub filtered" &&
              index > firstIndex
          );
          let indexRealEvent = session.findIndex(
            (event) => event == firstRealEvent
          );
          //Den Index des letzten Filterevents von hinten suchen, um das komplette Filterwort zu finden
          let tempsession = session.slice(0, indexRealEvent);
          let indexOfRelevantFiter = tempsession.findLastIndex(
            (event) => event.event == "Filter updated"
          );
          session.splice(firstIndex, indexOfRelevantFiter - firstIndex);
          //Nach weiteren Filterevents suchen
          removeDoubleFilterEvents(session, (startindex = firstIndex + 2));
        } //Wenn es keine Filterevents mehr gibt, zurück
        else {
          return session;
        }
      }

      function getStatusLineHeight() {
        return statusHeight + topPadding;
      }
      function getPubLineHeight(index) {
        return actionLineHeight + pubLineHeight + index * pubLineHeight + 5; //+5 für die Achse
      }

      //Pubevents: Filtern nach Pubs, die einmal in der Auswahl waren
      let dois = [];
      session
        .filter(
          (event) =>
            event.event == "Pub qd for selected" || event.event == "Pub added"
        )
        .forEach((event) => {
          dois.push(event.doi);
        });

      var uniqueDois = Array.from([...new Set(dois)]);

      //Hier nicht die Anzahl der finalen Pubs sondern Anzahl aller Pubs, die im Laufe der Session ausgewählt wurden
      let numberOfPubs = uniqueDois.length;
      //filter session to relevant pubs and action logs
      session = session.filter((event) => {
        if (event.doi) {
          return uniqueDois.includes(event.doi);
        } else {
          //keep action logs without pub doi, such as update
          return true;
        }
      });

      d3.select("#vis")
        .style("width", window.innerWidth * 0.9 + "px")
        .style("height", window.innerHeight * 0.9 + "px");

      //svg
      //Fenstergröße an die Anzahl der Pubs anpassen
      var svg = d3
        .select("#vis")
        .append("svg")
        .attr("width", width)
        .attr("height", getPubLineHeight(numberOfPubs + 1))
        .style("background-color", "white");

      //X Axis scale
      var xScale = d3
        .scaleLinear()
        .domain([session[0].date, session[session.length - 1].date])
        .range([legendPadding, width - 25])
        .nice();

      // action line x-axis

      svg
        .append("g")
        .attr("transform", "translate(0," + actionLineHeight + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      svg
        .append("g")
        .attr("transform", "translate(0," + getStatusLineHeight() + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      // Y axis Scale for number of selected pubs
      //event.actionDetails, weil die Nummer of SelectedPubs in Update gespeichert ist unter actionDetails
      var yScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            session.filter((event) => event.event == "Update"),
            (event) => parseInt(event.actionDetails)
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of selected pubs
      const yAxisTicks = yScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const yAxis = d3
        .axisLeft(yScale)
        .tickValues(yAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr("transform", "translate(130," + topPadding + ")")
        .call(yAxis);

      //Area chart number of selected Publications
      let updateEvents = session.filter((event) => event.event == "Update");
      svg
        .selectAll("mybar")
        .data(updateEvents)
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return xScale(d.date);
        })
        .attr("y", function (d) {
          return 10 + yScale(d.actionDetails);
        })
        .attr("width", (d, i) => {
          if (updateEvents[i + 1]) {
            return xScale(updateEvents[i + 1].date) - xScale(d.date);
          } else {
            return xScale(session[session.length - 1].date) - xScale(d.date);
          }
        })
        .attr("height", function (d) {
          return 100 - yScale(d.actionDetails);
        })
        .attr("fill", "#10d4b4");

      //line chart für Keywords
      var keywordScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            [
              d3.max(
                session.filter((event) => event.event == "Keywords updated"),
                (event) => parseInt(event.actionDetails.split("_").length)
              ),
              4,
            ] // either more than 4 keywords or 4 max number of filter
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of keywords
      const keywordAxisTicks = keywordScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const keywordAxis = d3
        .axisRight(keywordScale)
        .tickValues(keywordAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr(
          "transform",
          "translate(" +
            xScale(session[session.length - 1].date) +
            "," +
            topPadding +
            ")"
        )
        .call(keywordAxis);

      function drawKeywords(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter((event) => event.event == "Keywords updated")
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            currentY =
              keywordScale(event.actionDetails.split("_").length) + topPadding;
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      svg
        .append("path")
        .style("stroke", "#ffe48c")
        .style("stroke-width", 3)
        .style("fill", "none")
        .attr("d", drawKeywords(d3.path()));

      function drawFilter(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter(
            (event) =>
              event.event == "Filter updated" ||
              event.event == "Filter removed "
          )
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            let filter = event.actionDetails.split(/_|;/);
            let filterCount = 0;
            for (let i = 0; i < filter.length; i++) {
              if (filter[i]) {
                filterCount = filterCount + 1;
              }
            }
            console.log(keywordScale(filterCount));
            currentY = keywordScale(filterCount) + topPadding; //TODO: warum braucht man hier topPadding?
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      svg
        .append("path")
        .style("stroke", "#f0f4fc")
        .style("stroke-width", 3)
        .style("stroke-dasharray", (3, 3))
        .style("fill", "none")
        .attr("d", drawFilter(d3.path()));

      //Time axes for all publications that have been selected
      svg
        .selectAll("pubaxes")
        .data([1])
        //.data(Array.from({ length: numberOfPubs }, (value, index) => index))
        .enter()
        .append("g")
        .attr("id", "pubAxes")
        .attr(
          "transform",
          (d, i) => "translate (0, " + getPubLineHeight(numberOfPubs - 1) + ")"
        )
        .call(d3.axisBottom(xScale));

      function getStrokeColors(event) {
        if (event.activationSourceComponent) {
          switch (event.activationSourceComponent) {
            case "network":
              return "#807c7c";
            case "suggested":
              return "#408cd4";
            case "selected":
              return "#08d4b4";
            case "import":
              return "#08d4b4";
            default:
              return "red";
          }
        }
        return "white";
      }

      //Übersicht Farben: https://bulma.io/documentation/helpers/color-helpers/
      function getBarColors(event) {
        switch (event.event) {
          case "Pub imported":
            return "#08d4b4";
          case "Pub qd for selected":
            return "#f0fcfc";
          case "Pub added":
            return "#08d4b4";
          case "Pub suggested":
            return "#408cd4";
          case "Pub activated":
            return "#2160c4";
          case "Pub excluded":
            return "#f8446c";
          default:
            return "red";
        }
      }

      function getIconColors(event) {
        switch (event) {
          case "Pub qd for selected":
          case "Pub added":
            return "#f0fcfc";
          case "Pub suggested":
            return "#408cd4";
          case "Pub activated":
          case "Clicked doi":
          case "Clicked scholar":
            return "#e8e4e4";
          case "Keywords updated":
            return "#ffe48c";
          case "Pub excluded":
            return "#f8446c";
          case "Pub filtered":
          case "Filter updated":
          case "Filter removed":
            return "#f0f4fc";
          case "Network mode changed":
          case "Network collapsed":
          case "Network expanded":
          case "network":
            return "#807c7c";
          case "bookkeeping":
          case "Load more":
          case "Update":
            return "#383434";
          default:
            return "red";
        }
      }

      //Legende: Dois am linken Rand
      svg
        .selectAll("whatevs")
        .data(uniqueDois)
        .enter()
        .append("text")
        .attr("x", 5)
        .attr("y", (doi, index) => getPubLineHeight(index))
        .text((doi) => doi)
        .style("fill", "black")
        .style("font-size", "8px");

      //PubPointEvents = Events, die als Punkt auf der Pubtimeline erscheinen sollen
      let pubPointEvents = ["Pub filtered", "Clicked scholar", "Clicked doi"];

      //Bars mit extre Viereck statt Rahmen

      //Zustandsevents für Pubs, die als Balken erscheinen
      uniqueDois.forEach((doi) => {
        let barHeight = 16;
        let strokeWidth = 1;
        //alle Events einer Pub
        let eventsOfPub = session.filter(
          (event) => event.doi == doi && !pubPointEvents.includes(event.event)
        );

        eventsOfPub = eventsOfPub.filter(
          (checkEvent) =>
            checkEvent.event != "Pub deactivated" ||
            (checkEvent.event == "Pub deactivated" &&
              lastWasActivate(checkEvent, eventsOfPub))
        );

        let strokeEvents = ["Pub activated", "Pub qd for selected"];

        //Rahmen für Activated und qd
        svg
          .selectAll("barsbars")
          .data(
            eventsOfPub.filter((event) => strokeEvents.includes(event.event))
          )
          .enter()
          .append("rect")
          .attr("x", (d) => {
            return xScale(d.date);
          })
          .attr("y", (d) => {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight
            );
          })
          .attr("width", (d) => {
            let i = eventsOfPub.findIndex((event) => event == d);
            if (eventsOfPub[i + 1]) {
              return xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              return xScale(session[session.length - 1].date) - xScale(d.date);
            }
          })
          .attr("height", barHeight)
          .attr("fill", (event) => getStrokeColors(event))
          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));

        svg
          .selectAll("mybar")
          .data(eventsOfPub)
          .enter()
          .append("rect")
          .attr("x", (d) => {
            if (strokeEvents.includes(d.event)) {
              return xScale(d.date) + strokeWidth;
            }
            return xScale(d.date);
          })
          .attr("y", (d) => {
            let yPos =
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight;
            if (strokeEvents.includes(d.event)) {
              yPos = yPos + strokeWidth;
            }
            return yPos;
          })
          .attr("width", (d, i) => {
            let barWidth = 0;
            if (eventsOfPub[i + 1]) {
              barWidth = xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              barWidth =
                xScale(session[session.length - 1].date) - xScale(d.date);
            }
            if (strokeEvents.includes(d.event)) {
              barWidth = barWidth - strokeWidth * 2;
            }
            return barWidth;
          })
          .attr("height", function (d) {
            if (strokeEvents.includes(d.event)) {
              return barHeight - strokeWidth * 2;
            }
            return barHeight;
          })
          .attr("fill", (event,index) => {
            if (event.event == "Pub deactivated" ) {
              while(eventsOfPub[index-2].event == "Pub deactivated"){
                index = index-2
              }
              console.log(eventsOfPub[index-2]);
              return getBarColors(eventsOfPub[index-2])
              //Startindex = Pub deactivated
              //Rückwärtssuche nach dem vorletzten Event (das letzte müsste activate sein)
              //Farbe vom vorletzten Event zurückgeben

              //check if last was active
            }
            return getBarColors(event);
          })
          
          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));
      });

      let excludeForMask = [
        "end",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Load more",
        "Pub activated",
      ];

      //Maske
      uniqueDois.forEach((doi) => {
        //alle Events einer Pub
        let currentEvents = session
          .filter(
            (event) =>
              event.doi == doi &&
              event.event.startsWith("Pub") //&&
              //event.event != "Pub filtered"
          )
          .sort((a, b) => parseInt(a.date) - parseInt(b.date));
        svg
          .selectAll("mybar")
          .data(currentEvents)
          .enter()
          .append("rect")
          .attr("x", function (d) {
            return xScale(d.date);
          })
          .attr("y", function (d) {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) - 16
            );
          })
          .attr("width", (d, i) => {
            if (currentEvents[i + 1]) {
              return xScale(currentEvents[i + 1].date) - xScale(d.date);
            } else {
              return xScale(session[session.length - 1].date) - xScale(d.date);
            }
          })
          .attr("height", function (d, i) {
            // height = 0, if event is qd, added, excluded or activated
            // Pub deactivated => gleiche Maske wie für das vorhergehende Event (vgl. lastwasactive added actionDetails)
            if ( 
              [
                "Pub qd for selected",
                "Pub added",
                "Pub excluded",
                "Pub activated",
              ].includes(d.event) || (d.event == "Pub deactivated" &&  [
                "Pub qd for selected",
                "Pub added",
                "Pub excluded",
                "Pub activated",
              ].includes(d.actionDetails))
            ) {
              return 0;
            }
            let pos = d.posInSuggestions;
            //bottom 30 ganz weiß, dann in 5er Inkrementen jeweils 1 von 4 px wegnehmen
            if (pos > 30) {
              return 14;
            } else if (pos > 16) {
              return 10.5;
            } else if (pos > 10) {
              return 7;
            } else if (pos > 5) {
              return 3.5;
            }
          })
          .attr("fill", "white")
          .attr("opacity", 1)
          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));
      });

      let allEventTypes = [
        "Pub qd for selected",
        "Pub added",
        "Pub excluded",
        "Pub suggested",
        "Pub activated",
        "Pub filtered",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
      ];

      let legend1Drawn = false;
      let legend2Drawn = false;
      let legend3Drawn = false;

      //Punktevents für Actions
      svg
        .selectAll("whatever")
        .data(unfilteredActionEvents)
        .enter()
        .each(function (event, index) {
          let eventsRowOne = ["Pub activated", "Load more"];
          let eventsRowTwo = [
            "Pub qd for selected",
            "Pub added",
            "Pub imported",
            "Pub excluded",
            "Clicked doi",
            "Clicked scholar",
          ];
          let eventsRowThree = [
            "Filter updated",
            "Filter removed",
            "Keywords updated",
            "Network mode changed",
            "Network collapsed",
            "Network expanded",
          ];

          function getRowHeight(event) {
            if (eventsRowOne.includes(event.event)) {
              return 0;
            } else if (eventsRowTwo.includes(event.event)) {
              return 1;
            } else if (eventsRowThree.includes(event.event)) {
              return 2;
            }
          }

          let iconradius = 8;
          let strokeradius = 10;
          let strokewidth = 0; //Rand, um die Farbe des Strokes abzusetzen
          let imagesize = strokeradius;
          let yPosition =
            actionLineHeight -
            strokeradius -
            getRowHeight(event) * (strokeradius + strokeradius + strokewidth);

          //Legende: ActionLines

          if (!legend1Drawn && eventsRowOne.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Activation")
              .style("fill", "black")
              .style("font-size", "8px");
            legend1Drawn = true;
          } else if (!legend2Drawn && eventsRowTwo.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)

              .text("Pub Interactions")
              .style("fill", "black")
              .style("font-size", "8px");
            legend2Drawn = true;
          } else if (!legend3Drawn && eventsRowThree.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)

              .text("Interface Actions")
              .style("fill", "black")
              .style("font-size", "8px");
            legend3Drawn = true;
          }

          //Icon-Ränder (= größerer Kreis außerum => fill = stroke)
          d3.select(this)
            .append("circle")
            .attr("r", strokeradius)
            .attr("fill", (event) => getStrokeColors(event))
            .attr("stroke", "white")
            .attr("stroke-width", strokewidth)
            .attr("stroke-opacity", 0.8)
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition);

          //Icon
          d3.select(this)
            .append("circle")
            .attr("r", iconradius)
            .attr("fill", (event) => getIconColors(event.event))
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition)
            .on("mouseover", (event) => mouseover(event.event))
            .on("mouseout", (d, a) => mouseout(d, a));

          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - imagesize / 2)
            .attr("y", yPosition - imagesize / 2)
            .attr("width", imagesize)
            .attr("height", imagesize)
            .attr("href", (d) => getIconpath(d.event))
            .on("mouseover", (event) => mouseover(event.event))
            .on("mouseout", (d, a) => mouseout(d, a));
        });

      //Punktevents für Pubs
      svg
        .selectAll("whatever")
        .data(session.filter((event) => pubPointEvents.includes(event.event)))
        .enter()
        .each(function (event, index) {
          d3.select(this)
            .append("circle")
            .attr("r", 6)
            .attr("fill", (event) => {
              return getIconColors(event.event);
            })
            .attr("stroke", "black")
            .attr("stroke-width", 1)

            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr(
              "cy",
              (event) =>
                getPubLineHeight(
                  uniqueDois.findIndex((elem) => elem == event.doi)
                ) - 6
            )
            .on("mouseover", (event) => {
              console.log(event);
              mouseover(event.event);
            })
            .on("mouseout", (d, a) => mouseout(d, a));

          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - 4)
            .attr(
              "y",
              (event) =>
                getPubLineHeight(
                  uniqueDois.findIndex((elem) => elem == event.doi)
                ) - 10.5
            )
            .attr("width", 9)
            .attr("height", 9)
            .attr("href", (d) => getIconpath(d.event))
            .on("mouseover", (event) => {
              console.log(event);
mouseover(event.event)})
            .on("mouseout", (d, a) => mouseout(d, a));
        });

      function getIconpath(event) {
        let iconpath = "";
        switch (event) {
          case "Pub filtered":
          case "Filter updated":
            iconpath = "icons/filter.svg";
            break;
          case "Filter removed":
            iconpath = "icons/filter_off.svg";
            break;
          case "Clicked doi":
          case "Clicked scholar":
            iconpath = "icons/checkout.svg";
            break;
          case "Keywords updated":
            iconpath = "icons/boost.svg";
            break;
          case "Update":
            iconpath = "icons/update.svg";
            break;
          case "Load more":
            iconpath = "icons/load_more.svg";
            break;
          case "Network collapsed":
            iconpath = "icons/collapse.svg";
            break;
          case "Network expanded":
            iconpath = "icons/expand.svg";
            break;
          case "Network mode changed":
            iconpath = "icons/network_change.svg";
            break;
          case "Pub activated":
            iconpath = "icons/activate.svg";
            break;
          case "Pub imported":
          case "Pub qd for selected":
          case "Pub added":
            iconpath = "icons/qd.svg";
            break;
          case "Pub excluded":
            iconpath = "icons/exclude.svg";
            break;
          default:
            iconpath = "icons/filter_off.svg";
            break;
        }
        return iconpath;
      }
      function lastWasActivate(event, eventsOfPub) {
        //Den Index des letzten Filterevents von hinten suchen, um das komplette Filterwort zu finden
        let tempsession = eventsOfPub.slice(
          0,
          eventsOfPub.findIndex((checkEvent) => checkEvent == event)
        );
        let indexOfLastRelevantEvent = tempsession.findLastIndex(
          (checkEvent) => checkEvent.doi == event.doi
        );
        //Abspeichern unter actionDetails, was das vorhergehende Event war
        event.actionDetails = eventsOfPub[indexOfLastRelevantEvent].event;
        return eventsOfPub[indexOfLastRelevantEvent].event == "Pub activated";
      }
    }

    main();
  </script>
</body>
