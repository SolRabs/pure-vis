<!DOCTYPE html>
<meta charset="utf-8" />
<title>Graph Visualization</title>
<style>
  body {
    margin: 50px;
    font-family: Arial;
  }

  h2 {
    clear: both;
  }

  svg {
    float: left;
    border: 1px solid black;
    margin-bottom: 20px;
  }

  div#vis {
    position: absolute;
    top: 300px;
    height: 300px;
    width: 1200px;
    overflow: scroll;
  }
  #fitting {
    float: left;
  }

  #illfitting {
    float: left;
    padding-left: 20px;
  }
  #illfitting ul {
    height: 130px;
    overflow-y: scroll;
  }
  #fitting ul {
    height: 130px;
    overflow-y: scroll;
  }
</style>

<body>
  <script src="https://d3js.org/d3-array.v2.min.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <div>
    <select id="selectButton"></select>
    <label for="customPattern"></label>
    <input id="customPattern" placeholder="Pattern name" />
    <input id="customPatternDesc" placeholder="Pattern description" />
    <button id="saveButton">Save Pattern</button>
  </div>
  <br />
  <div>
    <input id="patternSetName" placeholder="Pattern set name" />
    <button id="exportButton">Export all Patterns</button>
  </div>
  <div id="fitting">
    <h2>Fitting Patterns:</h2>
    <ul></ul>
  </div>
  <div id="illfitting">
    <h2>Illfitting Patterns:</h2>
    <ul></ul>
  </div>
  <div id="vis"></div>

  <script>
    "use strict";
    async function loadData() {
      //const session = await d3.csv("data/test.csv");
      //const session = await d3.csv("data/session-long.csv");
      //const session = await d3.csv("data/session-all-patterns.csv");
      const session = await d3.csv("data/testsession.csv");
      return session;
    }

    async function main() {
      let session = await loadData();

      //Zeit umrechnen in Sekunden seit Start
      session.map(
        (event) =>
          (event.date =
            parseInt(event.date.split(":")[0] * 60 * 60) +
            parseInt(event.date.split(":")[1] * 60) +
            parseInt(event.date.split(":")[2]))
      );
      let start = session[0].date;
      session.map((event) => (event.date = event.date - start));

      let actionevents = [
        "Pub qd for selected",
        "Pub imported",
        "Pub excluded",
        "Pub activated",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
      ];
      removeDoubleFilterEvents(session);
      let unfilteredActionEvents = session.filter((event) =>
        actionevents.includes(event.event)
      );

      let width = window.innerWidth * 0.9;
      let height = window.innerHeight * 0.9;
      let statusHeight = 100;
      let pubLineHeight = 20;
      let topPadding = 10;
      let patternLineHeight = 20;
      let patternLineLocation = topPadding + statusHeight + patternLineHeight;
      let actionLineHeight = topPadding + 90 + statusHeight + patternLineHeight;
      let legendPadding = 130;
      let totalCircleRadius = 10;

      function mouseout(mouseData) {
        svg.select("#tooltip").remove();
      }

      function mouseover(mouseData) {
        svg.append("g").attr("id", "tooltip");
        let tooltipX = event.pageX;
        let tooltipY = event.pageY;
        d3.select("#tooltip")
          .append("rect")
          .attr("x", tooltipX)
          .attr("y", tooltipY)
          .attr("width", 200)
          .attr("height", 30)
          .attr("fill", "white")
          .attr("stroke", "black");
        d3.select("#tooltip")
          .append("text")
          .attr("x", tooltipX + 10)
          .attr("y", tooltipY + 20)
          .attr("stroke", "black")
          .text(mouseData);
      }

      //Überflüssige Filterevents (Teilworte) entfernen.
      function removeDoubleFilterEvents(session, startindex = 0) {
        //Erster Buchstabe des Filters finden
        let firstFilterEvent = session.find(
          (event) =>
            event.event == "Filter updated" &&
            session.findIndex((current) => current == event) > startindex
        );

        if (firstFilterEvent) {
          let firstIndex = session.findIndex(
            (event) => event == firstFilterEvent
          );

          let firstRealEvent = session.find(
            (event, index) =>
              event.event != "Filter updated" &&
              event.event != "Pub filtered" &&
              index > firstIndex
          );
          let indexRealEvent = session.findIndex(
            (event) => event == firstRealEvent
          );
          //Den Index des letzten Filterevents von hinten suchen, um das komplette Filterwort zu finden
          let tempsession = session.slice(0, indexRealEvent);
          let indexOfRelevantFiter = tempsession.findLastIndex(
            (event) => event.event == "Filter updated"
          );
          session.splice(firstIndex, indexOfRelevantFiter - firstIndex);
          //Nach weiteren Filterevents suchen
          removeDoubleFilterEvents(session, (startindex = firstIndex + 2));
        } //Wenn es keine Filterevents mehr gibt, zurück
        else {
          return session;
        }
      }

      function getStatusLineHeight() {
        return statusHeight + topPadding;
      }
      function getPubLineHeight(index) {
        return actionLineHeight + pubLineHeight + index * pubLineHeight + 5; //+5 für die Achse
      }

      //Pubevents: Filtern nach Pubs, die einmal in der Auswahl waren
      let dois = [];
      session
        .filter(
          (event) =>
            event.event == "Pub qd for selected" || event.event == "Pub added"
        )
        .forEach((event) => {
          dois.push(event.doi);
        });

      var uniqueDois = Array.from([...new Set(dois)]);

      //Hier nicht die Anzahl der finalen Pubs sondern Anzahl aller Pubs, die im Laufe der Session ausgewählt wurden
      let numberOfPubs = uniqueDois.length;
      //filter session to relevant pubs and action logs
      session = session.filter((event) => {
        if (event.doi) {
          return uniqueDois.includes(event.doi);
        } else {
          //keep action logs without pub doi, such as update
          return true;
        }
      });

      //Select Button
      var patterns = ["custom", "seed", "refine", "check", "explore", "curate"];

      // add the options to the button
      d3.select("#selectButton")
        .selectAll("myOptions")
        .data(patterns)
        .enter()
        .append("option")
        .text((d) => d)
        .attr("value", (d) => d);

      d3.select("#vis")
        .style("width", window.innerWidth * 0.9 + "px")
        .style("height", window.innerHeight * 0.9 + "px");

      //svg
      //Fenstergröße an die Anzahl der Pubs anpassen
      var svg = d3
        .select("#vis")
        .append("svg")
        .attr("width", width)
        .attr("height", getPubLineHeight(numberOfPubs + 1))
        .style("background-color", "white");

      //X Axis scale
      var xScale = d3
        .scaleLinear()
        .domain([session[0].date, session[session.length - 1].date])
        .range([legendPadding, width - 25])
        .nice();

      // pattern line x-axis
      svg
        .append("g")
        .attr(
          "transform",
          "translate(0," +
            (patternLineLocation + patternLineHeight * 0.75) +
            ")"
        )
        .call(d3.axisBottom(xScale).tickValues([]));

      svg
        .append("text")
        .attr("x", 5)
        .attr("y", patternLineLocation + patternLineHeight * 0.75 + 3)
        .text("Patterns")
        .style("fill", "black")
        .style("font-size", "8px");

      // action line x-axis

      svg
        .append("g")
        .attr("transform", "translate(0," + actionLineHeight + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      svg
        .append("g")
        .attr("transform", "translate(0," + getStatusLineHeight() + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      // Y axis Scale for number of selected pubs
      //event.actionDetails, weil die Nummer of SelectedPubs in Update gespeichert ist unter actionDetails
      var yScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            session.filter((event) => event.event == "Update"),
            (event) => parseInt(event.actionDetails)
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of selected pubs
      const yAxisTicks = yScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const yAxis = d3
        .axisLeft(yScale)
        .tickValues(yAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr("transform", "translate(130," + topPadding + ")")
        .call(yAxis);

      //Area chart number of selected Publications
      let updateEvents = session.filter((event) => event.event == "Update");
      svg
        .selectAll("mybar")
        .data(updateEvents)
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return xScale(d.date);
        })
        .attr("y", function (d) {
          return 10 + yScale(d.actionDetails);
        })
        .attr("width", (d, i) => {
          if (updateEvents[i + 1]) {
            return xScale(updateEvents[i + 1].date) - xScale(d.date);
          } else {
            return xScale(session[session.length - 1].date) - xScale(d.date);
          }
        })
        .attr("height", function (d) {
          return 100 - yScale(d.actionDetails);
        })
        .attr("fill", "#10d4b4");

      //line chart für Keywords
      var keywordScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            [
              d3.max(
                session.filter((event) => event.event == "Keywords updated"),
                (event) => parseInt(event.actionDetails.split("_").length)
              ),
              4,
            ] // either more than 4 keywords or 4 max number of filter
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of keywords
      const keywordAxisTicks = keywordScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const keywordAxis = d3
        .axisRight(keywordScale)
        .tickValues(keywordAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr(
          "transform",
          "translate(" +
            xScale(session[session.length - 1].date) +
            "," +
            topPadding +
            ")"
        )
        .call(keywordAxis);

      function drawKeywords(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter((event) => event.event == "Keywords updated")
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            currentY =
              keywordScale(event.actionDetails.split("_").length) + topPadding;
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      svg
        .append("path")
        .style("stroke", "#ffe48c")
        .style("stroke-width", 3)
        .style("fill", "none")
        .attr("d", drawKeywords(d3.path()));

      function drawFilter(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter(
            (event) =>
              event.event == "Filter updated" ||
              event.event == "Filter removed "
          )
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            let filter = event.actionDetails.split(/_|;/);
            let filterCount = 0;
            for (let i = 0; i < filter.length; i++) {
              if (filter[i]) {
                filterCount = filterCount + 1;
              }
            }
            currentY = keywordScale(filterCount) + topPadding; //TODO: warum braucht man hier topPadding?
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      svg
        .append("path")
        .style("stroke", "#f0f4fc")
        .style("stroke-width", 3)
        .style("stroke-dasharray", (3, 3))
        .style("fill", "none")
        .attr("d", drawFilter(d3.path()));

      //Time axes for all publications that have been selected
      svg
        .selectAll("pubaxes")
        .data([1])
        //.data(Array.from({ length: numberOfPubs }, (value, index) => index))
        .enter()
        .append("g")
        .attr("id", "pubAxes")
        .attr(
          "transform",
          (d, i) => "translate (0, " + getPubLineHeight(numberOfPubs - 1) + ")"
        )
        .call(d3.axisBottom(xScale));

      function getStrokeColors(event) {
        if (event.activationSourceComponent) {
          switch (event.activationSourceComponent) {
            case "network":
              return "#807c7c";
            case "suggested":
              return "#408cd4";
            case "selected":
              return "#08d4b4";
            case "import":
              return "#08d4b4";
            default:
              return "red";
          }
        }
        return "white";
      }

      //Übersicht Farben: https://bulma.io/documentation/helpers/color-helpers/
      function getBarColors(event) {
        switch (event.event) {
          case "Pub imported":
            return "#08d4b4";
          case "Pub qd for selected":
            return "#f0fcfc";
          case "Pub added":
            return "#08d4b4";
          case "Pub suggested":
            return "#408cd4";
          case "Pub activated":
            return "#2160c4";
          case "Pub excluded":
            return "#f8446c";
          default:
            return "red";
        }
      }

      function getIconColors(event) {
        switch (event) {
          case "Pub qd for selected":
          case "Pub added":
            return "#f0fcfc";
          case "Pub suggested":
            return "#408cd4";
          case "Pub activated":
          case "Clicked doi":
          case "Clicked scholar":
            return "#e8e4e4";
          case "Keywords updated":
            return "#ffe48c";
          case "Pub excluded":
            return "#f8446c";
          case "Pub filtered":
          case "Filter updated":
          case "Filter removed":
            return "#f0f4fc";
          case "Network mode changed":
          case "Network collapsed":
          case "Network expanded":
          case "network":
            return "#807c7c";
          case "bookkeeping":
          case "Load more":
          case "Update":
            return "#383434";
          default:
            return "red";
        }
      }

      function getPatternColors(pattern) {
        switch (pattern) {
          case "seed":
            return "#08d4b4";
          case "refine":
            return "#ffe48c";
          case "check":
            return "#408cd4";
          case "explore":
            return "#807c7c";
          case "curate":
            return "#f8446c";
          default:
            return "#28d464";
        }
      }

      //Legende: Dois am linken Rand
      svg
        .selectAll("whatevs")
        .data(uniqueDois)
        .enter()
        .append("text")
        .attr("x", 5)
        .attr("y", (doi, index) => getPubLineHeight(index))
        .text((doi) => doi)
        .style("fill", "black")
        .style("font-size", "8px");

      //PubPointEvents = Events, die als Punkt auf der Pubtimeline erscheinen sollen
      let pubPointEvents = ["Pub filtered", "Clicked scholar", "Clicked doi"];

      //Bars mit extra Viereck statt Rahmen

      //Zustandsevents für Pubs, die als Balken erscheinen
      uniqueDois.forEach((doi) => {
        let barHeight = 16;
        let strokeWidth = 1;
        //alle Events einer Pub
        let eventsOfPub = session.filter(
          (event) => event.doi == doi && !pubPointEvents.includes(event.event)
        );

        eventsOfPub = eventsOfPub.filter(
          (checkEvent) =>
            checkEvent.event != "Pub deactivated" ||
            (checkEvent.event == "Pub deactivated" &&
              lastWasActivate(checkEvent, eventsOfPub))
        );

        let strokeEvents = ["Pub activated", "Pub qd for selected"];

        //Rahmen für Activated und qd
        svg
          .selectAll("barsbars")
          .data(
            eventsOfPub.filter((event) => strokeEvents.includes(event.event))
          )
          .enter()
          .append("rect")
          .attr("x", (d) => {
            return xScale(d.date);
          })
          .attr("y", (d) => {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight
            );
          })
          .attr("width", (d) => {
            let i = eventsOfPub.findIndex((event) => event == d);
            if (eventsOfPub[i + 1]) {
              return xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              return xScale(session[session.length - 1].date) - xScale(d.date);
            }
          })
          .attr("height", barHeight)
          .attr("fill", (event) => getStrokeColors(event))
          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));

        svg
          .selectAll("mybar")
          .data(eventsOfPub)
          .enter()
          .append("rect")
          .attr("x", (d) => {
            if (strokeEvents.includes(d.event)) {
              return xScale(d.date) + strokeWidth;
            }
            return xScale(d.date);
          })
          .attr("y", (d) => {
            let yPos =
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight;
            if (strokeEvents.includes(d.event)) {
              yPos = yPos + strokeWidth;
            }
            return yPos;
          })
          .attr("width", (d, i) => {
            let barWidth = 0;
            if (eventsOfPub[i + 1]) {
              barWidth = xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              barWidth =
                xScale(session[session.length - 1].date) - xScale(d.date);
            }
            if (strokeEvents.includes(d.event)) {
              barWidth = barWidth - strokeWidth * 2;
            }
            return barWidth;
          })
          .attr("height", function (d) {
            if (strokeEvents.includes(d.event)) {
              return barHeight - strokeWidth * 2;
            }
            return barHeight;
          })
          .attr("fill", (event, index) => {
            if (event.event == "Pub deactivated") {
              while (eventsOfPub[index - 2].event == "Pub deactivated") {
                index = index - 2;
              }
              return getBarColors(eventsOfPub[index - 2]);
              //Startindex = Pub deactivated
              //Rückwärtssuche nach dem vorletzten Event (das letzte müsste activate sein)
              //Farbe vom vorletzten Event zurückgeben

              //check if last was active
            }
            return getBarColors(event);
          })

          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));
      });

      let excludeForMask = [
        "end",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Load more",
        "Pub activated",
      ];

      //Maske
      uniqueDois.forEach((doi) => {
        //alle Events einer Pub
        let currentEvents = session
          .filter(
            (event) => event.doi == doi && event.event.startsWith("Pub") //&&
            //event.event != "Pub filtered"
          )
          .sort((a, b) => parseInt(a.date) - parseInt(b.date));
        svg
          .selectAll("mybar")
          .data(currentEvents)
          .enter()
          .append("rect")
          .attr("x", function (d) {
            return xScale(d.date);
          })
          .attr("y", function (d) {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) - 16
            );
          })
          .attr("width", (d, i) => {
            if (currentEvents[i + 1]) {
              return xScale(currentEvents[i + 1].date) - xScale(d.date);
            } else {
              return xScale(session[session.length - 1].date) - xScale(d.date);
            }
          })
          .attr("height", function (d, i) {
            // height = 0, if event is qd, added, excluded or activated
            // Pub deactivated => gleiche Maske wie für das vorhergehende Event (vgl. lastwasactive added actionDetails)
            if (
              [
                "Pub qd for selected",
                "Pub added",
                "Pub excluded",
                "Pub activated",
              ].includes(d.event) ||
              (d.event == "Pub deactivated" &&
                [
                  "Pub qd for selected",
                  "Pub added",
                  "Pub excluded",
                  "Pub activated",
                ].includes(d.actionDetails))
            ) {
              return 0;
            }
            let pos = d.posInSuggestions;
            //bottom 30 ganz weiß, dann in 5er Inkrementen jeweils 1 von 4 px wegnehmen
            if (pos > 30) {
              return 14;
            } else if (pos > 16) {
              return 10.5;
            } else if (pos > 10) {
              return 7;
            } else if (pos > 5) {
              return 3.5;
            }
          })
          .attr("fill", "white")
          .attr("opacity", 1)
          .on("mouseover", (event) => mouseover(event.event))
          .on("mouseout", (d, a) => mouseout(d, a));
      });

      let legend1Drawn = false;
      let legend2Drawn = false;
      let legend3Drawn = false;

      //Punktevents für Actions
      svg
        .selectAll("whatever")
        .data(unfilteredActionEvents)
        .enter()
        .each(function (event, index) {
          let eventsRowOne = ["Pub activated", "Load more"];
          let eventsRowTwo = [
            "Pub qd for selected",
            "Pub added",
            "Pub imported",
            "Pub excluded",
            "Clicked doi",
            "Clicked scholar",
          ];
          let eventsRowThree = [
            "Filter updated",
            "Filter removed",
            "Keywords updated",
            "Network mode changed",
            "Network collapsed",
            "Network expanded",
          ];

          function getRowHeight(event) {
            if (eventsRowOne.includes(event.event)) {
              return 0;
            } else if (eventsRowTwo.includes(event.event)) {
              return 1;
            } else if (eventsRowThree.includes(event.event)) {
              return 2;
            }
          }

          let iconradius = 8;
          let strokeradius = totalCircleRadius;
          let strokewidth = 0; //Rand, um die Farbe des Strokes abzusetzen
          let imagesize = strokeradius;
          let yPosition =
            actionLineHeight -
            strokeradius -
            getRowHeight(event) * (strokeradius + strokeradius + strokewidth);

          //Legende: ActionLines

          if (!legend1Drawn && eventsRowOne.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Activation")
              .style("fill", "black")
              .style("font-size", "8px");
            legend1Drawn = true;
          } else if (!legend2Drawn && eventsRowTwo.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)

              .text("Pub Interactions")
              .style("fill", "black")
              .style("font-size", "8px");
            legend2Drawn = true;
          } else if (!legend3Drawn && eventsRowThree.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Interface Actions")
              .style("fill", "black")
              .style("font-size", "8px");
            legend3Drawn = true;
          }

          //Icon-Ränder (= größerer Kreis außerum => fill = stroke)
          d3.select(this)
            .append("circle")
            .attr("r", strokeradius)
            .attr("fill", (event) => getStrokeColors(event))
            .attr("stroke", "white")
            .attr("stroke-width", strokewidth)
            .attr("stroke-opacity", 0.8)
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition);

          //Icon
          d3.select(this)
            .append("circle")
            .attr("r", iconradius)
            .attr("fill", (event) => getIconColors(event.event))
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition)
            .on("mouseover", (event) => mouseover(event.event))
            .on("mouseout", (d, a) => mouseout(d, a));

          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - imagesize / 2)
            .attr("y", yPosition - imagesize / 2)
            .attr("width", imagesize)
            .attr("height", imagesize)
            .attr("href", (d) => getIconpath(d.event))
            .on("mouseover", (event) => mouseover(event.event))
            .on("mouseout", (d, a) => mouseout(d, a));
        });

      //Punktevents für Pubs
      svg
        .selectAll("whatever")
        .data(session.filter((event) => pubPointEvents.includes(event.event)))
        .enter()
        .each(function (event, index) {
          d3.select(this)
            .append("circle")
            .attr("r", 6)
            .attr("fill", (event) => {
              return getIconColors(event.event);
            })
            .attr("stroke", "black")
            .attr("stroke-width", 1)

            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr(
              "cy",
              (event) =>
                getPubLineHeight(
                  uniqueDois.findIndex((elem) => elem == event.doi)
                ) - 6
            )
            .on("mouseover", (event) => {
              console.log(event);
              mouseover(event.event);
            })
            .on("mouseout", (d, a) => mouseout(d, a));

          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - 4)
            .attr(
              "y",
              (event) =>
                getPubLineHeight(
                  uniqueDois.findIndex((elem) => elem == event.doi)
                ) - 10.5
            )
            .attr("width", 9)
            .attr("height", 9)
            .attr("href", (d) => getIconpath(d.event))
            .on("mouseover", (event) => {
              console.log(event);
              mouseover(event.event);
            })
            .on("mouseout", (d, a) => mouseout(d, a));
        });

      function getIconpath(event) {
        let iconpath = "";
        switch (event) {
          case "Pub filtered":
          case "Filter updated":
            iconpath = "icons/filter.svg";
            break;
          case "Filter removed":
            iconpath = "icons/filter_off.svg";
            break;
          case "Clicked doi":
          case "Clicked scholar":
            iconpath = "icons/checkout.svg";
            break;
          case "Keywords updated":
            iconpath = "icons/boost.svg";
            break;
          case "Update":
            iconpath = "icons/update.svg";
            break;
          case "Load more":
            iconpath = "icons/load_more.svg";
            break;
          case "Network collapsed":
            iconpath = "icons/collapse.svg";
            break;
          case "Network expanded":
            iconpath = "icons/expand.svg";
            break;
          case "Network mode changed":
            iconpath = "icons/network_change.svg";
            break;
          case "Pub activated":
            iconpath = "icons/activate.svg";
            break;
          case "Pub imported":
          case "Pub qd for selected":
          case "Pub added":
            iconpath = "icons/qd.svg";
            break;
          case "Pub excluded":
            iconpath = "icons/exclude.svg";
            break;
          default:
            iconpath = "icons/filter_off.svg";
            break;
        }
        return iconpath;
      }
      function lastWasActivate(event, eventsOfPub) {
        //Den Index des letzten Filterevents von hinten suchen, um das komplette Filterwort zu finden
        let tempsession = eventsOfPub.slice(
          0,
          eventsOfPub.findIndex((checkEvent) => checkEvent == event)
        );
        let indexOfLastRelevantEvent = tempsession.findLastIndex(
          (checkEvent) => checkEvent.doi == event.doi
        );
        //Abspeichern unter actionDetails, was das vorhergehende Event war
        event.actionDetails = eventsOfPub[indexOfLastRelevantEvent].event;
        return eventsOfPub[indexOfLastRelevantEvent].event == "Pub activated";
      }

      let allEventTypes = [
        "Pub qd for selected",
        "Pub added",
        "Pub excluded",
        "Pub suggested",
        "Pub activated",
        "Pub filtered",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
      ];

      function isCheckOrExplore(event, checkOrExplore) {
        //Nur mit Origin suggested
        let origin = [
          "Pub activated",
          "Clicked doi",
          "Clicked scholar",
          "Pub qd for selected",
          "Pub added",
          "Pub excluded",
        ];

        //ok
        let pass = ["Network collapsed", "Filter removed", "Load more"];

        //Netzwerkevents
        let networkEvents = [
          "Network mode changed",
          "Network collapsed",
          "Network expanded",
        ];

        //excludeEvents werden nicht mit einbezogen!
        let excludeEvents = [
          "Filter updated",
          "Keywords updated",
          "Network mode changed",
          "Network collapsed",
          "Network expanded",
        ];
        //irrelevant:
        let irrelevant = ["Pub suggested", "Pub filtered"];

        //Check
        if (checkOrExplore == "check") {
          return (
            (origin.includes(event.event) &&
              event.activationSourceComponent == "suggested") ||
            pass.includes(event.event)
          );
        } else if (checkOrExplore == "explore") {
          return (
            (origin.includes(event.event) &&
              event.activationSourceComponent == "network") ||
            pass.includes(event.event) ||
            networkEvents.includes(event.event)
          );
        }
      }

      //Brushing

      const gb = svg.append("g").call(
        d3
          .brushX()
          .extent([
            [legendPadding, actionLineHeight - 70],
            [width - 25, actionLineHeight],
          ])
          .on("brush", brushed)
      );

      //Globale Variablen für Selection und Pattern
      var currentPattern = patterns[0];
      var currentSelection = [];

      //Update Selection in globaler Variable (Dauer, Liste der Events)
      //Update Anzeige Anzahl und Art passender/unpassender Ereignisse
      function brushed(brushevent) {
        let start = brushevent.selection[0];
        let end = brushevent.selection[1];
        let selected = unfilteredActionEvents.filter(
          (event) =>
            start < xScale(new Date(event.date)) &&
            end > xScale(new Date(event.date))
        );
        currentSelection = selected;
        updateFittingPatterns();
      }
      //Vorgehen: Typ auswählen und filtern nach fitting und nicht fitting events
      //Für jeden Pattern eine boolean Funktion, die abklärt, ob das Event zum Pattern passt oder nicht

      //Eingabe des current Pattern => update current Pattern
      //und Anzeige der fitting und nicht fitting Ereignisse => extra Methode
      d3.select("#selectButton").on("change", function (d) {
        // recover the option that has been chosen
        currentPattern = d3.select(this).property("value");
        updateFittingPatterns();
      });

      function matchPattern(currentPattern, event) {
        switch (currentPattern) {
          case "seed":
            return (
              (event.event == "Pub qd for selected" &&
                event.activationSourceComponent == "import") ||
              event.event == "Pub added"
            );
          case "refine":
            return ![
              "Pub qd for selected",
              "Pub added",
              "Pub excluded",
            ].includes(event.event);
          case "check":
            return isCheckOrExplore(event, "check");
          case "explore":
            return isCheckOrExplore(event, "explore");

          case "curate":
            return (
              (event.event == "Pub activated" &&
                event.activationSourceComponent == "selected") ||
              event.event == "Pub excluded"
            );

          default:
            return true;
        }
      }
      function updateFittingPatterns() {
        let fittingPatterns = currentSelection.filter((event) =>
          matchPattern(currentPattern, event)
        );
        let illfittingPatterns = currentSelection.filter(
          (event) => !matchPattern(currentPattern, event)
        );

        function updateLists(ul, currentEvents) {
          let elementTypes = [];
          currentEvents.forEach((event) => {
            elementTypes.push(event.event);
          });

          let data = new Set(elementTypes);

          //remove duplicates / get event types only
          // Select all list items
          const li = ul.selectAll("li").data(data);

          // Update existing items
          li.text((d) => {
            return (
              d +
              " (" +
              currentEvents.filter((event) => event.event === d).length +
              ")"
            );
          });

          // Enter new items
          li.enter()
            .append("li")
            .text(
              (d) =>
                d +
                " (" +
                currentEvents.filter((event) => event.event === d).length +
                ")"
            );

          // Exit old items
          li.exit().remove();
        }
        updateLists(d3.select("#fitting ul"), fittingPatterns);
        updateLists(d3.select("#illfitting ul"), illfittingPatterns);
      }

      var detectedPatterns = [];
      var patternsAsJson = [];
      d3.select("#saveButton").on("click", function (d) {
        if (currentSelection.length == 0) {
          console.log("No events in selection for pattern.");
          return;
        }
        let start = currentSelection[0].date;
        let end = currentSelection[currentSelection.length - 1].date;
        let patternName = currentPattern;
        let patternDesc = "";
        if (currentPattern == "custom") {
          patternName = document.getElementById("customPattern").value;
          patternDesc = document.getElementById("customPatternDesc").value;
        }
        var pattern = {
          patternName: patternName,
          patternDesc: patternDesc,
          patternStart: start,
          patternEnd: end,
          duration: end - start,
          eventCount: currentSelection.length,
          patternId: detectedPatterns.length,
          illFittingEventsCount: currentSelection.filter(
            (event) => !matchPattern(currentPattern, event)
          ).length,
        };

        // Converting the object to a JSON string
        var jsonString = JSON.stringify(pattern);

        patternsAsJson.push(jsonString);

        //Pattern einzeichnen (mit Position und entsprechender Farbe bei Balken
        //oberhalb von Actionlines (Muster für Vergleiche))
        detectedPatterns.push(pattern);
        console.log("Saved " + patternName + " pattern.");
        //Hier detected Patterns Zeichen update triggern
        drawPatterns();
        //document.querySelectorAll("div input").value = "Jep";

        document.querySelectorAll("div input").forEach(function (input) {
          input.value = "";
          // Trigger the placeholder to be displayed
          input.blur();
          input.focus();
        });
      });

      function drawPatterns() {
        var removeSelection = d3
          .select("body > div#vis > svg")
          .selectAll("rect#patternbars");

        removeSelection.remove();

        svg
          .selectAll("#whatever")
          .data(detectedPatterns)
          .enter()
          .append("rect")
          .attr("id", "patternbars")
          .attr("x", function (d) {
            return xScale(d.patternStart) - totalCircleRadius;
          })
          .attr("y", function (d) {
            if (
              Boolean(
                detectedPatterns.filter(
                  (pattern) =>
                    pattern.patternId < d.patternId &&
                    ((pattern.patternStart >= d.patternStart &&
                      pattern.patternStart <= d.patternEnd) ||
                      (pattern.patternEnd >= d.patternStart &&
                        pattern.patternEnd <= d.patternEnd) ||
                      (pattern.patternEnd >= d.patternEnd &&
                        pattern.patternStart <= d.patternStart))
                ).length
              )
            ) {
              return patternLineLocation - 10;
            } else {
              return patternLineLocation;
            }
          })
          .attr("width", (d) => {
            //2 * totalCircleRadius, weil der Timestamp im Kreis im Mittelpunkt is => + 2* Radius für rechts und links
            return (
              xScale(d.patternEnd) -
              xScale(d.patternStart) +
              2 * totalCircleRadius
            );
          })
          .attr("height", function (d) {
            return patternLineHeight * 0.75;
          })
          .attr("fill", (d) => getPatternColors(d.patternName));
      }

      d3.select("#exportButton").on("click", function (d) {
        patternSetName = document.getElementById("patternSetName").value;
        if (patternSetName == "" || patternSetName == "Pattern set name") {
          console.log("Pattern Set Name missing");
        } else {
          console.log({
            patternSetName: patternSetName,
            patterns: patternsAsJson,
          });
        }
      });
    }

    main();
  </script>
</body>
