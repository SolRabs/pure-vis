<!DOCTYPE html>
<meta charset="utf-8" />
<title>Session overview</title>
<style>
  body {
    margin: 50px;
    font-family: Arial;
  }

  h2 {
    clear: both;
  }

  svg {
    float: left;
    border: 1px solid black;
    margin-bottom: 20px;
  }

  div#vis {
    position: absolute;
    top: 150px;
    height: 300px;
    width: 1200px;
  }
</style>

<body>
  <script src="node_modules/d3/dist/d3.min.js"></script>
  <div>
    <select id="selectButton"></select>
    <label for="customPattern"></label>
    <input id="customPattern" placeholder="Pattern name" />
    <input id="customPatternDesc" placeholder="Pattern description" />
    <button id="saveButton">Save Pattern</button>
  </div>
  <br />
  <div>
    <input id="patternSetName" placeholder="Pattern set name" />
    <button id="exportButton">Export all Patterns</button>
  </div>
  <div id="vis"></div>
  <div
    class="testtip"
    style="
      opacity: 0;
      background-color: white;
      border: solid 2px;
      border-radius: 5px;
      padding: 5px;
      position: absolute;
      left: 413.5px;
      top: 156px;
      height: auto;
      width: 150px;
      overflow: auto;
      word-wrap: break-word;
    "
  ></div>

  <script>
    ("use strict");

    async function loadData() {
      var queryStr = window.location.search;
      var params = {};
      if (!queryStr) {
        //const filename = "sessionLog.csv";
        //const filename = "test";
        //const filename = "testsession.csv";
        //const filename = "session-long.csv";
        //const filename = "session-all-patterns.csv"
        const filename = "s1_t1_solveig_probe_1";
        window.location.search = "?session=" + filename;
        params["session"] = filename;
      }

      var paramPairs = queryStr.substr(1).split("&");
      for (var i = 0; i < paramPairs.length; i++) {
        var parts = paramPairs[i].split("=");
        params[parts[0]] = parts[1];
      }

      const session = await d3.csv("data/" + params["session"] + ".csv");
      try {
        const providedPatternSet = await d3.json(
          "data/" + params["patternSet"] + ".json"
        );
        return [session, providedPatternSet];
      } catch (error) {
        //no pattern set provided
        return [session, []];
      }
    }

    async function main() {
      let providedData = await loadData();
      let session = providedData[0];
      let providedPatternSet = providedData[1];

      //let session = await loadData();

      //Zeit umrechnen in Sekunden seit Start
      session.map(
        (event) =>
          (event.date =
            parseInt(event.date.split(":")[0] * 60 * 60) +
            parseInt(event.date.split(":")[1] * 60) +
            parseInt(event.date.split(":")[2]))
      );

      let start = session[0].date;
      session.map((event) => (event.date = event.date - start));

      alternativeRemoveDoubleFilterEvents(session);

      let actionevents = [
        "Pub qd for selected",
        "Pub imported",
        "Pub excluded",
        "Pub activated",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Clicked abstract",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
        "Refined authors",
        "Clicked author scholar",
        "Opened authors",
        "Closed authors",
        "Opened search",
        "Closed search",
        "Network nodes shown updated",
        "Network: shown authors updated",
        "Network: shown suggested updated",
        "Keyword dragged",
      ];
      let unfilteredActionEvents = session.filter((event) =>
        actionevents.includes(event.event)
      );

      let width = window.innerWidth * 0.9;
      let height = window.innerHeight * 0.9;
      let statusHeight = 100;
      let pubLineHeight = 30;
      let barHeight = 16;
      let topPadding = 10;
      let patternLineHeight = 20;
      let patternLineLocation = topPadding + statusHeight + patternLineHeight;
      let actionLineHeight = topPadding + 90 + statusHeight + patternLineHeight;
      let legendPadding = 130;
      let totalCircleRadius = 10;
      let xAxisEnd = width - 40;

      const mouseover = function (event, d) {
        console.log(d);
        if (d.title.length > 0) {
          tooltiptext = "<b>" + d.title + "</b>:" + d.event;
        } else if (d.doi) {
          let titlefound;
          let publist = session.filter((event) => event.doi == d.doi);
          let index = 0;
          while (index < publist.length && !titlefound > 0) {
            if (
              publist[index].title.length > 0 &&
              publist[index].title != "undefined"
            ) {
              titlefound = publist[index].title;
            }
            index++;
          }
          if (!titlefound || titlefound.length < 0) {
            titlefound = publist[0].doi;
          }
          tooltiptext = "<b>" + titlefound + "</b>:" + d.event;
        } else {
          tooltiptext = d.event;
        }
        if (d.activationSourceComponent) {
          tooltiptext = tooltiptext + " in " + d.activationSourceComponent + "";
        }
        if (d.event == "Pub suggested" || d.event == "Pub filtered") {
          tooltiptext += ` (Position ${d.posInSuggestions})`;
        }
        if (d.actionDetails) {
          const replaceCommas = [
            "Filter updated",
            "Keywords",
            "Network",
            "Filter removed",
          ];

          if (replaceCommas.some((type) => d.event.startsWith(type))) {
            //Filter enthalten _ zwischen den Filterworten => bessere Lesbarkeit

            let actionDetails = d.actionDetails.replaceAll("_", ",");
            actionDetails = actionDetails
              .replace(/^,+/g, "")
              .replace(/,+$/g, "");
            tooltiptext += ` (${actionDetails})`;
          } else {
            tooltiptext += ` (${d.actionDetails})`;
          }
        }

        d3.select(".testtip")
          .style("opacity", 1)
          .style("height", "auto")
          .style("width", "auto")
          .style("max-width", "200px")
          .html(tooltiptext + "<br>");

        d3.select(this).style("stroke", "black").style("opacity", 1);

        if (d.doi) {
          d3.selectAll("." + "Pub" + d.doi.replace(/[^0-9]/g, ""))
            .style("stroke", "purple")
            .style("stroke-width", 3)
            .style("opacity", 1);

          if (uniqueDois.indexOf(d.doi) > -1) {
            svg
              .append("line")
              .attr("id", "hoveredPub")
              .attr("x1", xScale(session[0].date))
              .attr("y1", getPubLineHeight(uniqueDois.indexOf(d.doi)) + 1)
              .attr("x2", xScale(session[session.length - 1].date))
              .attr("y2", getPubLineHeight(uniqueDois.indexOf(d.doi)) + 1)
              .attr("stroke", "purple")
              .attr("stroke-width", 2);
          }
        }
      };

      const mousemove = function (event, d) {
        let addHeight =
          document.getElementById("vis").getBoundingClientRect().top +
          window.scrollY -
          document.getElementById("vis").scrollTop +
          30;
        d3.select(".testtip")
          .style("left", d3.pointer(event)[0] + 70 + "px")
          .style("top", d3.pointer(event)[1] + addHeight + "px");
      };

      const mouseleave = function (event, d) {
        d3.select(".testtip")
          .style("opacity", 0)
          .style("height", 0)
          .style("width", 0);

        d3.select(this).style("stroke", "none");

        d3.selectAll(".Pub" + d.doi.replace(/[^0-9]/g, "")).style(
          "stroke",
          "none"
        );
        d3.select("#hoveredPub").remove();
      };

      //Überflüssige Filterevents (Teilworte) entfernen.
      function removeDoubleFilterEvents(session, startIndex = 0) {
        //Ersten Buchstabe des Filters finden
        let firstFilterEvent = session.find(
          (event) =>
            event.event == "Filter updated" &&
            session.findIndex((current) => current == event) > startindex
        );

        if (firstFilterEvent) {
          let firstIndex = session.findIndex(
            (event) => event == firstFilterEvent
          );

          let firstRealEvent = session.find(
            (event, index) =>
              event.event != "Filter updated" &&
              event.event != "Pub filtered" &&
              index > firstIndex
          );
          let indexRealEvent = session.findIndex(
            (event) => event == firstRealEvent
          );
          // Finde the second to last "Filter updated" event, (=> das letzt irrelevante Filter updated event)
          // Find the index of the next non-"Filter updated" event after the sequence

          let indexOfLastIrrelevantFilterUpdated = -1;
          for (let i = indexRealEvent - 2; i > filterIndex; i--) {
            if (session[i].event == "Filter updated") {
              indexOfLastIrrelevantFilterUpdated = i;
              break;
            }
          }
          for (
            let i = filterIndex;
            i <= indexOfLastIrrelevantFilterUpdated;
            i++
          ) {
            console.log(session[i]);
          }
          session.splice(
            filterIndex,
            indexOfLastIrrelevantFilterUpdated - filterIndex
          );
          //Nach weiteren Filterevents suchen
          removeDoubleFilterEvents(session, (startindex = firstIndex + 2));
        } //Wenn es keine Filterevents mehr gibt, zurück
        else {
          return session;
        }
      }

      function alternativeRemoveDoubleFilterEvents(session) {
        let startIndex = 0;

        while (startIndex < session.length) {
          // Find the index of the next "Filter updated" event
          const filterIndex = session.findIndex(
            (event, index) =>
              index >= startIndex && event.event === "Filter updated"
          );

          if (filterIndex === -1) break; // No more "Filter updated" events

          // Find the index of the next non-"Filter updated" event after the sequence
          const endIndex = session.findIndex(
            (event, index) =>
              index > filterIndex &&
              event.event !== "Filter updated" &&
              event.event != "Pub filtered"
          );

          if (endIndex === -1) {
            // No more non-"Filter updated" events
            session.splice(filterIndex); // Remove all events from filterIndex to the end
            break;
          }

          // Finde the second to last "Filter updated" event, (=> das letzt irrelevante Filter updated event)

          let indexOfLastIrrelevantFilterUpdated = -1;
          for (let i = endIndex - 2; i > filterIndex; i--) {
            if (session[i].event == "Filter updated") {
              indexOfLastIrrelevantFilterUpdated = i;
              break;
            }
          }
          session.splice(
            filterIndex,
            indexOfLastIrrelevantFilterUpdated - filterIndex
          );
          // Update startIndex to continue searching from after the removed sequence
          startIndex = endIndex;
        }
        return session;
      }

      function getStatusLineHeight() {
        return statusHeight + topPadding;
      }
      function getPubLineHeight(index) {
        return actionLineHeight + pubLineHeight + index * pubLineHeight + 5; //+5 für die Achse
      }

      //Pubevents: Filtern nach Pubs, die einmal in der Auswahl waren
      let dois = [];
      session
        .filter(
          (event) =>
            event.event == "Pub qd for selected" || event.event == "Pub added"
        )
        .forEach((event) => {
          dois.push(event.doi);
        });

      var uniqueDois = Array.from([...new Set(dois)]);

      //Hier nicht die Anzahl der finalen Pubs sondern Anzahl aller Pubs, die im Laufe der Session ausgewählt wurden
      let numberOfPubs = uniqueDois.length;
      //filter session to relevant pubs and action logs
      session = session.filter((event) => {
        if (event.doi) {
          return uniqueDois.includes(event.doi);
        } else {
          //keep action logs without pub doi, such as update
          return true;
        }
      });

      //Select Button
      // var patterns = ["custom","seed", "keywords","ranking","pub character","filter","refinement","clusters","timeline","authors", "curate"]
      var patterns = ["custom", "blue", "grey", "yellow", "red"];
      // add the options to the button
      d3.select("#selectButton")
        .selectAll("myOptions")
        .data(patterns)
        .enter()
        .append("option")
        .text((d) => d)
        .attr("value", (d) => d);

      d3.select("#vis")
        .style("width", window.innerWidth * 0.9 + "px")
        .style("height", window.innerHeight * 0.9 + "px");

      //svg
      //Fenstergröße an die Anzahl der Pubs anpassen
      var svg = d3
        .select("#vis")
        .append("svg")
        .attr("width", width)
        .attr("height", getPubLineHeight(numberOfPubs + 1))
        .style("background-color", "white");

      //X Axis scale
      var xScale = d3
        .scaleLinear()
        .domain([session[0].date, session[session.length - 1].date])
        .range([legendPadding, xAxisEnd])
        .nice();

      // pattern line x-axis
      svg
        .append("g")
        .attr(
          "transform",
          "translate(0," +
            (patternLineLocation + patternLineHeight * 0.75) +
            ")"
        )
        .call(d3.axisBottom(xScale).tickValues([]));

      //legende: patternline
      svg
        .append("text")
        .attr("x", 5)
        .attr("y", patternLineLocation + patternLineHeight * 0.75 + 3)
        .text("Patterns")
        .style("fill", "black")
        .style("font-size", "10px");

      //Brush area

      const gb = svg.append("g").call(
        d3
          .brushX()
          .extent([
            [legendPadding, actionLineHeight - 70],
            [xAxisEnd, actionLineHeight],
          ])
          .on("brush", brushed)
      );

      // action line x-axis

      svg
        .append("g")
        .attr("transform", "translate(0," + actionLineHeight + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      svg
        .append("g")
        .attr("transform", "translate(0," + getStatusLineHeight() + ")")
        .call(d3.axisBottom(xScale).tickValues([]));

      // Y axis Scale for number of selected pubs
      //event.actionDetails, weil die Nummer of SelectedPubs in Update gespeichert ist unter actionDetails
      var yScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            session.filter((event) => event.event == "Update"),
            (event) => parseInt(event.actionDetails)
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of selected pubs
      const yAxisTicks = yScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const yAxis = d3
        .axisLeft(yScale)
        .tickValues(yAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr("transform", "translate(130," + topPadding + ")")
        .call(yAxis);

      //Area chart number of selected Publications
      let updateEvents = session.filter((event) => event.event == "Update");
      svg
        .selectAll("mybar")
        .data(updateEvents)
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return xScale(d.date);
        })
        .attr("y", function (d) {
          return 10 + yScale(d.actionDetails);
        })
        .attr("width", (d, i) => {
          if (updateEvents[i + 1]) {
            return xScale(updateEvents[i + 1].date) - xScale(d.date);
          } else {
            return xScale(session[session.length - 1].date) - xScale(d.date);
          }
        })
        .attr("height", function (d) {
          return 100 - yScale(d.actionDetails);
        })
        .attr("fill", "#10d4b4");

      //Area chart number of selected Publications from user perspective
      let userPerspectiveAreaChart = session.filter(
        (event) =>
          event.event == "Pub qd for selected" ||
          (event.event == "Pub excluded" &&
            event.activationSourceComponent == "selected") ||
          (event.event == "Pub excluded" &&
            event.activationSourceComponent == "network" &&
            session.some(
              (otherEvent) =>
                event.doi == otherEvent.doi && otherEvent.event == "Pub added"
            )) ||
          event.event == "Update"
      );

      let actualSelectedPubsCounter = 0;
      let actualSelectedPubsCounter2 = 0;

      svg
        .selectAll("userperspect")
        .data(userPerspectiveAreaChart)
        .enter()
        .append("rect")
        .attr("x", function (d) {
          return xScale(d.date);
        })
        .attr("y", function (d) {
          if (d.event == "Update") {
            actualSelectedPubsCounter = d.actionDetails;
            return 10 + yScale(d.actionDetails);
          } else if (d.event == "Pub excluded") {
            actualSelectedPubsCounter--;
            return 10 + yScale(actualSelectedPubsCounter);
          } else if (d.event == "Pub qd for selected")
            actualSelectedPubsCounter++;
          return 10 + yScale(actualSelectedPubsCounter);
        })
        .attr("width", (d, i) => {
          if (userPerspectiveAreaChart[i + 1]) {
            return (
              xScale(userPerspectiveAreaChart[i + 1].date) - xScale(d.date)
            );
          } else {
            return xScale(session[session.length - 1].date) - xScale(d.date);
          }
        })
        .attr("height", function (d) {
          if (d.event == "Update") {
            actualSelectedPubsCounter2 = d.actionDetails;
            return 100 - yScale(d.actionDetails);
          } else if (d.event == "Pub excluded") {
            actualSelectedPubsCounter2--;
            return 100 - yScale(actualSelectedPubsCounter2);
          } else if (d.event == "Pub qd for selected")
            actualSelectedPubsCounter2++;
          return 100 - yScale(actualSelectedPubsCounter2);
        })
        .attr("fill", "#408cd4")
        .attr("opacity", 0.7);

      //line chart für Keywords
      var keywordScale = d3
        .scaleLinear()
        .domain([
          0,
          d3.max(
            // either more than 4 keywords or 4 max number of filter
            [
              d3.max(
                session.filter((event) => event.event == "Keywords updated"),
                (event) =>
                  parseInt(
                    event.actionDetails
                      .split("_")
                      .filter((str) => str.trim() !== "").length
                  )
              ),
              4,
            ]
          ),
        ])
        .range([100, 0]);

      //Add y axis Einheit: number of keywords
      const keywordAxisTicks = keywordScale
        .ticks()
        .filter((tick) => Number.isInteger(tick));

      const keywordAxis = d3
        .axisRight(keywordScale)
        .tickValues(keywordAxisTicks)
        .tickFormat(d3.format("d"));

      svg
        .append("g")
        .attr("class", "keyword-axis")
        .attr("transform", "translate(" + xAxisEnd + "," + topPadding + ")")
        .call(keywordAxis);

      // Append selected-axis label
      svg
        .append("text")
        .attr("class", "y-axis-label")
        .attr("x", -yScale(0) + 40)
        .attr("y", xScale(0) - 35)
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .style("font-size", "10px")
        .text("Number of selected");

      // Append keyword-axis label
      svg
        .append("text")
        .attr("class", "y-axis-label")
        .attr("x", yScale(0) - 40)
        .attr("y", -(xAxisEnd + 35))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .attr("transform", "rotate(90)")
        .style("font-size", "10px")
        .text("Number of keywords/filter");

      function drawKeywords(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter((event) => event.event == "Keywords updated")
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            currentY =
              keywordScale(
                event.actionDetails
                  .split("_")
                  .filter((str) => str.trim() !== "").length
              ) + topPadding;
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      //draw keyword line
      svg
        .append("path")
        .style("stroke", "#ffe48c")
        .style("stroke-width", 3)
        .style("fill", "none")
        .attr("d", drawKeywords(d3.path()));

      //draw keyword bubbles
      svg
        .selectAll("dr")
        .data(session.filter((event) => event.event == "Keywords updated"))
        .enter()
        .append("circle")
        .attr("cx", (event) => {
          return xScale(event.date);
        })
        .attr("cy", (event) => {
          return (
            keywordScale(
              event.actionDetails.split("_").filter((str) => str.trim() !== "")
                .length
            ) + topPadding
          );
        })
        .attr("r", 5)
        .style("fill", "#ffe48c");

      function drawFilter(context) {
        context.moveTo(legendPadding, getStatusLineHeight());
        let currentY = getStatusLineHeight();
        let currentX = legendPadding;
        session
          .filter(
            (event) =>
              event.event == "Filter updated" || event.event == "Filter removed"
          )
          .forEach((event) => {
            context.lineTo(xScale(event.date), currentY);
            let filter = event.actionDetails.split(/_|;/);
            let filterCount = 0;
            for (let i = 0; i < filter.length; i++) {
              if (filter[i]) {
                filterCount = filterCount + 1;
              }
            }
            currentY = keywordScale(filterCount) + topPadding; //TODO: warum braucht man hier topPadding?
            context.lineTo(xScale(event.date), currentY);
            currentX = xScale(event.date);
          });
        context.lineTo(xScale(session[session.length - 1].date), currentY);
        return context;
      }

      //draw filter lines
      svg
        .append("path")
        .style("stroke", "#f0f4fc")
        .style("stroke-width", 3)
        .style("stroke-dasharray", (3, 3))
        .style("fill", "none")
        .attr("d", drawFilter(d3.path()));

      //draw filter bubbles
      svg
        .selectAll("dr")
        .data(
          session.filter(
            (event) =>
              event.event == "Filter updated" || event.event == "Filter removed"
          )
        )
        .enter()
        .append("circle")
        .attr("cx", (event) => {
          return xScale(event.date);
        })
        .attr("cy", (event) => {
          return (
            keywordScale(
              event.actionDetails.split("_").filter((str) => str.trim() !== "")
                .length
            ) + topPadding
          );
        })
        .attr("r", 5)
        .style("fill", "#f0f4fc");

      //Time axes for all publications that have been selected
      svg
        .selectAll("pubaxes")
        .data([1])
        .enter()
        .append("g")
        .attr("id", "pubAxes")
        .attr(
          "transform",
          (d, i) => "translate (0, " + getPubLineHeight(numberOfPubs - 1) + ")"
        )
        .call(d3.axisBottom(xScale));

      function getStrokeColors(event) {
        if (event.activationSourceComponent) {
          switch (event.activationSourceComponent) {
            case "network":
              return "#807c7c";
            case "suggested":
              return "#408cd4";
            case "selected":
              return "#08d4b4";
            case "import":
              return "#08d4b4";
            default:
              return "red";
          }
        }
        return "white";
      }

      //Übersicht Farben: https://bulma.io/documentation/helpers/color-helpers/
      function getBarColors(event) {
        switch (event.event) {
          case "Pub imported":
            return "#08d4b4";
          case "Pub qd for selected":
            return "#f0fcfc";
          case "Pub added":
            return "#08d4b4";
          case "Pub suggested":
          case "Pub filtered":
            return "#408cd4";
          case "Pub activated":
            return "#2160c4";
          case "Pub excluded":
            return "#f8446c";
          default:
            return "red";
        }
      }

      function getIconColors(event) {
        switch (event) {
          case "Pub qd for selected":
          case "Pub added":
            return "#f0fcfc";
          case "Pub suggested":
            return "#408cd4";
          case "Pub activated":
          case "Clicked doi":
          case "Clicked scholar":
          case "Clicked abstract":
            return "#e8e4e4";
          case "Keywords updated":
          case "Refined authors":
            return "#ffe48c";
          case "Pub excluded":
            return "#f8446c";
          case "Pub filtered":
          case "Filter updated":
          case "Filter removed":
            return "#f0f4fc";
          case "Network nodes shown updated":
          case "Network: shown authors updated":
          case "Network: shown suggested updated":
          case "Network mode changed":
          case "Network collapsed":
          case "Network expanded":
          case "network":
          case "Keyword dragged":
            return "#807c7c";
          case "bookkeeping":
          case "Load more":
          case "Update":
            return "#383434";
          case "Clicked author scholar":
          case "Opened search":
          case "Closed search":
          case "Opened authors":
          case "Closed authors":
            return "#08d4b4";
          default:
            return "red";
        }
      }

      function getPatternColors(pattern) {
        switch (pattern) {
          case "seed":
            return "#08d4b4";
          case "keywords":
          case "yellow":
            return "#ffe48c";
          case "ranking":
          case "pub character":
          case "filter":
          case "refinement":
          case "blue":
            return "#408cd4";
          case "clusters":
          case "timeline":
          case "authors":
          case "grey":
            return "#807c7c";
          case "curate":
          case "red":
            return "#f8446c";
          default:
            return "#28d464";
        }
      }

      //Legende: Dois am linken Rand
      svg
        .selectAll("whatevs")
        .data(uniqueDois)
        .enter()
        .append("text")
        .attr("x", 5)
        .attr("y", (doi, index) => getPubLineHeight(index))
        .text((doi) => {
          let publist = session.filter((event) => event.doi == doi);
          let index = 0;
          while (index < publist.length) {
            if (
              publist[index].title.length > 0 &&
              publist[index].title != "undefined"
            ) {
              return publist[index].title.substr(0, 25);
            }
            index++;
          }
          return publist[0].doi.substr(0, 25);
        })
        .style("fill", "black")
        .style("font-size", "10px");

      //Legende: Timeline-legende
      svg
        .append("text")
        .attr("x", xScale(session[session.length - 1].date) - 70)
        .attr("y", getPubLineHeight(uniqueDois.length))
        .text("Elapsed time (seconds)")
        .style("fill", "black")
        .style("font-size", "10px");

      //PubPointEvents = Events, die als Punkt auf der Pubtimeline erscheinen sollen
      let pubPointEvents = [
        "Pub filtered",
        "Clicked scholar",
        "Clicked doi",
        "Clicked abstract",
      ];

      //Zustandsevents für Pubs, die als Balken erscheinen
      uniqueDois.forEach((doi) => {
        let strokeWidth = 1;
        //alle Events einer Pub
        let eventsOfPub = session.filter(
          (event) =>
            event.doi == doi &&
            !["Clicked scholar", "Clicked doi", "Clicked abstract"].includes(
              event.event
            )
        );

        eventsOfPub = eventsOfPub.filter(
          (checkEvent, currentIndex) =>
            checkEvent.event != "Pub deactivated" ||
            (checkEvent.event == "Pub deactivated" &&
              lastWasActivate(checkEvent, eventsOfPub))
        );

        //Entfernen von Pub suggested logging nach Pub qd for selected
        let i = 0;
        let indexToRemove = [];
        while (i < eventsOfPub.length - 1) {
          if (eventsOfPub[i].event == "Pub qd for selected") {
            let a = i + 1;
            while (
              eventsOfPub[a].event == "Pub suggested" ||
              eventsOfPub[a].event == "Pub filtered"
            ) {
              indexToRemove.push(a);
              a++;
            }
            i = a;
          } else {
            i++;
          }
        }
        eventsOfPub = eventsOfPub.filter(
          (event, index) => !indexToRemove.includes(index)
        );

        let strokeEvents = ["Pub activated", "Pub qd for selected"];

        //Rahmen für Activated und qd
        svg
          .selectAll("barsbars")
          .data(
            eventsOfPub.filter((event) => strokeEvents.includes(event.event))
          )
          .enter()
          .append("rect")
          .attr("x", (d) => {
            return xScale(d.date);
          })
          .attr("y", (d) => {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight
            );
          })
          .attr("width", (d) => {
            let i = eventsOfPub.findIndex((event) => event == d);
            if (eventsOfPub[i + 1]) {
              return xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              return xScale(session[session.length - 1].date) - xScale(d.date);
            }
          })
          .attr("height", barHeight)
          .attr("fill", (event) => getStrokeColors(event))
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);

        //Gruppen für die Barevents erstellen
        var bars = svg.selectAll("mybar").data(eventsOfPub);

        bars
          .enter()
          .append("rect")
          .attr("x", (d) => {
            if (strokeEvents.includes(d.event)) {
              return xScale(d.date) + strokeWidth;
            }
            return xScale(d.date);
          })
          .attr("y", (d) => {
            let yPos =
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight;
            if (strokeEvents.includes(d.event)) {
              return yPos + strokeWidth;
            } else if (
              d.event == "Pub suggested" ||
              d.event == "Pub filtered"
            ) {
              if (d.posInSuggestions > 30) {
                return yPos + 15;
              } else {
                return yPos + d.posInSuggestions / 2;
              }
            }
            return yPos;
          })
          .attr("width", (d, i) => {
            let barWidth = 0;
            if (eventsOfPub[i + 1]) {
              barWidth = xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              barWidth =
                xScale(session[session.length - 1].date) - xScale(d.date);
            }
            if (strokeEvents.includes(d.event)) {
              barWidth = barWidth - strokeWidth * 2;
            }
            return barWidth;
          })
          .attr("height", function (d) {
            if (strokeEvents.includes(d.event)) {
              return barHeight - strokeWidth * 2;
            } else if (
              d.event == "Pub suggested" ||
              d.event == "Pub filtered"
            ) {
              let pos = d.posInSuggestions;
              //bottom 30 ganz weiß, dann in 5er Inkrementen jeweils 1 von 4 px wegnehmen
              barHeight = 16;
              if (pos > 30) {
                return barHeight - 15;
              } else {
                return barHeight - pos / 2;
              }
            }
            return barHeight;
          })
          .attr("fill", (event, index) => {
            if (event.event == "Pub deactivated") {
              while (
                ["Pub deactivated", "Pub activated"].includes(
                  eventsOfPub[index - 1].event
                )
              ) {
                index = index - 1;
              }
              return getBarColors(eventsOfPub[index - 1]);
            }
            return getBarColors(event);
          })
          .style("pointer-events", "none");

        bars
          .enter()
          .append("rect")
          .attr("x", (d) => {
            if (strokeEvents.includes(d.event)) {
              return xScale(d.date) + strokeWidth;
            }
            return xScale(d.date);
          })
          .attr("y", (d) => {
            return (
              getPubLineHeight(uniqueDois.findIndex((doi) => doi == d.doi)) -
              barHeight
            );
          })
          .attr("width", (d, i) => {
            let barWidth = 0;
            if (eventsOfPub[i + 1]) {
              barWidth = xScale(eventsOfPub[i + 1].date) - xScale(d.date);
            } else {
              barWidth =
                xScale(session[session.length - 1].date) - xScale(d.date);
            }
            if (strokeEvents.includes(d.event)) {
              barWidth = barWidth - strokeWidth * 2;
            }
            return barWidth;
          })
          .attr("height", barHeight)
          .attr("fill", "transparent")
          .on("mouseover", mouseover)
          .on("mousemove", mousemove)
          .on("mouseleave", mouseleave);
      });

      //Update Linien
      svg
        .selectAll("hi")
        .data(session.filter((event) => event.event == "Update"))
        .enter()
        .append("line")
        .attr("x1", (event) => xScale(event.date))
        .attr("y1", getPubLineHeight(0))
        .attr("x2", (event) => xScale(event.date))
        .attr("y2", getPubLineHeight(uniqueDois.length - 1))
        .attr("stroke", "grey")
        .attr("stroke-width", 2)
        .attr("opacity", 0.1);

      let legend1Drawn = false;
      let legend2Drawn = false;
      let legend3Drawn = false;

      //Punktevents für Actions
      svg
        .selectAll("whatever")
        .data(unfilteredActionEvents)
        .enter()
        .each(function (event, index) {
          let eventsRowOne = ["Pub activated", "Load more"];
          let eventsRowTwo = [
            "Pub qd for selected",
            "Pub added",
            "Pub imported",
            "Pub excluded",
            "Clicked doi",
            "Clicked scholar",
            "Clicked abstract",
          ];
          let eventsRowThree = [
            "Filter updated",
            "Filter removed",
            "Keywords updated",
            "Network mode changed",
            "Network collapsed",
            "Network expanded",
            "Opened authors",
            "Closed authors",
            "Opened search",
            "Closed search",
            "Refined authors",
            "Clicked author scholar",
            "Network nodes shown updated",
            "Network: shown authors updated",
            "Network: shown suggested updated",
            "Keyword dragged",
          ];

          function getRowHeight(event) {
            if (eventsRowOne.includes(event.event)) {
              return 0;
            } else if (eventsRowTwo.includes(event.event)) {
              return 1;
            } else if (eventsRowThree.includes(event.event)) {
              return 2;
            }
          }

          let iconradius = 8;
          let strokeradius = totalCircleRadius;
          let strokewidth = 0; //Rand, um die Farbe des Strokes abzusetzen
          let imagesize = strokeradius;
          let yPosition =
            actionLineHeight -
            strokeradius -
            getRowHeight(event) * (strokeradius + strokeradius + strokewidth);

          //Legende: ActionLines

          if (!legend1Drawn && eventsRowOne.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Activation")
              .style("fill", "black")
              .style("font-size", "10px");
            legend1Drawn = true;
          } else if (!legend2Drawn && eventsRowTwo.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Pub Interactions")
              .style("fill", "black")
              .style("font-size", "10px");
            legend2Drawn = true;
          } else if (!legend3Drawn && eventsRowThree.includes(event.event)) {
            svg
              .append("text")
              .attr("x", 5)
              .attr("y", yPosition + 3)
              .text("Interface Actions")
              .style("fill", "black")
              .style("font-size", "10px");
            legend3Drawn = true;
          }

          //Icon-Ränder (= größerer Kreis außerum => fill = stroke)
          d3.select(this)
            .append("circle")
            .attr("class", (event) => {
              if (event.doi.replace(/[^0-9]/g, "")) {
                return "Pub" + event.doi.replace(/[^0-9]/g, "");
              } else {
                return "";
              }
            })
            .attr("r", strokeradius)
            .attr("fill", (event) => getStrokeColors(event))
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition);

          //Icon
          d3.select(this)
            .append("circle")
            .attr("r", iconradius)
            .attr("fill", (event) => getIconColors(event.event))
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => yPosition)
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseleave", mouseleave);

          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - imagesize / 2)
            .attr("y", yPosition - imagesize / 2)
            .attr("width", imagesize)
            .attr("height", imagesize)
            .attr("href", (d) => getIconpath(d.event))
            .style("pointer-events", "none");
        });

      let indexOfkeywordMatches = [];

      session.filter((event, index) => {
        let keywordsMatch = false;
        if (event.event == "Keywords updated") {
          let keywords = event.actionDetails.split("_");
          //see max of next 50 recommendations
          for (let i = index + 1; i < index + 50; i++) {
            const log = session[i];
            if (log.event == "Pub suggested") {
              keywords.forEach((keyword) => {
                for (let j = 0; j <= log.title.length - keyword.length; j++) {
                  const substring = log.title.substring(j, j + keyword.length);
                  if (substring.toLowerCase().includes(keyword.toLowerCase())) {
                    indexOfkeywordMatches.push(i);
                  }
                }
              });
            } else {
              break;
            }
          }
        }
      });

      //Punktevents für Pubs
      svg
        .selectAll("whatever")
        .data(
          session.filter((event, index) => {
            return (
              pubPointEvents.includes(event.event) ||
              indexOfkeywordMatches.includes(index)
            );
          })
        )
        .enter()
        .each(function (event, index) {
          d3.select(this)
            .append("circle")
            .attr("r", (event) => {
              //if pub suggested is a point event, it matched a keyword
              if (event.event == "Pub suggested" || event.event == "Pub filtered") {
                return 3;
              } else return 6;
            })
            .attr("fill", (event) => {
              //if pub suggested is a point event, it matched a keyword
              if (event.event == "Pub suggested") {
                return "#ffe48c";
              } 
              return getIconColors(event.event);
            })
            .attr("stroke", (event) => {
              //if pub suggested is a point event, it matched a keyword
              if (event.event == "Pub suggested") {
                return "#ffe48c";
              }

              return getStrokeColors(event);
            })
            .attr("stroke-width", 1)
            .attr("cx", (event) => xScale(new Date(event.date)))
            .attr("cy", (event) => {
              //if pub suggested is a point event, it matched a keyword
              if (event.event == "Pub suggested" || event.event == "Pub filtered") {
                return (
                  getPubLineHeight(
                    uniqueDois.findIndex((elem) => elem == event.doi)
                  ) - 4
                );
              }
              return getPubLineHeight(
                uniqueDois.findIndex((elem) => elem == event.doi)
              ) - 7;
            })
            .on("mouseover", mouseover)
            .on("mousemove", mousemove)
            .on("mouseleave", mouseleave);

            if (event.event != "Pub suggested" && event.event != "Pub filtered")
          d3.select(this)
            .append("image")
            .attr("id", "icon")
            .attr("x", (event) => xScale(new Date(event.date)) - 4)
            .attr(
              "y",
              (event) =>
                getPubLineHeight(
                  uniqueDois.findIndex((elem) => elem == event.doi)
                ) - 11.5
            )
            .attr("width", 9)
            .attr("height", 9)
            .attr("href", (d) => getIconpath(d.event))
            .style("pointer-events", "none");
        });

      function getIconpath(event) {
        let iconpath = "";
        switch (event) {
          case "Pub filtered":
          case "Filter updated":
            iconpath = "icons/filter.svg";
            break;
          case "Filter removed":
            iconpath = "icons/filter_off.svg";
            break;
          case "Clicked doi":
          case "Clicked scholar":
            iconpath = "icons/checkout.svg";
            break;
          case "Clicked abstract":
            iconpath = "icons/abstract.svg";
            break;
          case "Keywords updated":
          case "Keyword dragged":
            iconpath = "icons/boost.svg";
            break;
          case "Update":
            iconpath = "icons/update.svg";
            break;
          case "Load more":
            iconpath = "icons/load_more.svg";
            break;
          case "Network collapsed":
            iconpath = "icons/collapse.svg";
            break;
          case "Network expanded":
            iconpath = "icons/expand.svg";
            break;
          case "Network mode changed":
            iconpath = "icons/network_change.svg";
            break;
          case "Pub activated":
            iconpath = "icons/activate.svg";
            break;
          case "Pub imported":
          case "Pub qd for selected":
          case "Pub added":
            iconpath = "icons/qd.svg";
            break;
          case "Pub excluded":
            iconpath = "icons/exclude.svg";
            break;
          case "Opened authors":
            iconpath = "icons/open-authors.svg";
            break;
          case "Closed authors":
            iconpath = "icons/close-authors.svg";
            break;
          case "Opened search":
            iconpath = "icons/open-search.svg";
            break;
          case "Closed search":
            iconpath = "icons/close-search.svg";
            break;
          case "Refined authors":
            iconpath = "icons/refine-author.svg";
            break;
          case "Clicked author scholar":
            iconpath = "icons/author-scholar.svg";
            break;
          case "Network nodes shown updated":
          case "Network: shown authors updated":
          case "Network: shown suggested updated":
            iconpath = "icons/nodes.svg";
            break;
        }
        return iconpath;
      }
      function lastWasActivate(event, eventsOfPub) {
        //Den Index des letzten Filterevents von hinten suchen, um das komplette Filterwort zu finden
        let tempsession = eventsOfPub.slice(
          0,
          eventsOfPub.findIndex((checkEvent) => checkEvent == event)
        );
        let indexOfLastRelevantEvent = tempsession.findLastIndex(
          (checkEvent) => checkEvent.doi == event.doi
        );
        //Abspeichern unter actionDetails, was das vorhergehende Event war
        event.actionDetails = eventsOfPub[indexOfLastRelevantEvent].event;
        return eventsOfPub[indexOfLastRelevantEvent].event == "Pub activated";
      }

      let allEventTypes = [
        "Pub qd for selected",
        "Pub added",
        "Pub excluded",
        "Pub suggested",
        "Pub activated",
        "Pub filtered",
        "Network mode changed",
        "Network collapsed",
        "Network expanded",
        "Clicked doi",
        "Clicked scholar",
        "Filter updated",
        "Filter removed",
        "Keywords updated",
        "Load more",
        "Refined authors",
        "Clicked author scholar",
        "Opened authors",
        "Closed authors",
        "Opened search",
        "Closed search",
        "Network nodes shown updated",
        "Network: shown authors updated",
        "Network: shown suggested updated",
      ];

      function isCheckOrExplore(event, checkOrExplore) {
        //Nur mit Origin suggested
        let origin = [
          "Pub activated",
          "Clicked doi",
          "Clicked scholar",
          "Pub qd for selected",
          "Pub added",
          "Pub excluded",
        ];

        //ok
        let pass = ["Network collapsed", "Filter removed", "Load more"];

        //Netzwerkevents
        let networkEvents = [
          "Network mode changed",
          "Network collapsed",
          "Network expanded",
          "Network nodes shown updated",
          "Network: shown authors updated",
          "Network: shown suggested updated",
        ];

        //excludeEvents werden nicht mit einbezogen!
        let excludeEvents = [
          "Filter updated",
          "Keywords updated",
          "Network mode changed",
          "Network collapsed",
          "Network expanded",
          "Network nodes shown updated",
          "Network: shown authors updated",
          "Network: shown suggested updated",
        ];

        //Check
        if (checkOrExplore == "check") {
          return (
            (origin.includes(event.event) &&
              event.activationSourceComponent == "suggested") ||
            pass.includes(event.event)
          );
        } else if (checkOrExplore == "explore") {
          return (
            (origin.includes(event.event) &&
              event.activationSourceComponent == "network") ||
            pass.includes(event.event) ||
            networkEvents.includes(event.event)
          );
        }
      }

      //Globale Variablen für Selection und Pattern
      var currentPattern = patterns[0];
      var currentEventSelection = [];
      var currentDateSelection = [];
      var currentBrushEvent = [];

      //Update Selection in globaler Variable (Dauer, Liste der Events)
      //Update Anzeige Anzahl und Art passender/unpassender Ereignisse
      function brushed(brushevent) {
        console.log(brushevent.selection);
        //get events in selection
        let start = brushevent.selection[0];
        let end = brushevent.selection[1];
        let selected = unfilteredActionEvents.filter(
          (event) =>
            start < xScale(new Date(event.date)) &&
            end > xScale(new Date(event.date))
        );
        currentEventSelection = selected;
        //just take the currentBrushEvent for saving pattern
        currentBrushEvent = brushevent;
        console.log(currentBrushEvent);
      }

      d3.select("#selectButton").on("change", function (d) {
        // recover the option that has been chosen
        currentPattern = d3.select(this).property("value");
      });

      var detectedPatterns = [];
      var patternsAsJson = [];

      if (providedPatternSet) {
        patternsAsJson = providedPatternSet;
        detectedPatterns = providedPatternSet;
        drawPatterns();
      }

      d3.select("#saveButton").on("click", function (d) {
        //save start and end of pattern in terms of timestamp to later compare absolute timings
        let start = xScale.invert(currentBrushEvent.selection[0]);
        let end = xScale.invert(currentBrushEvent.selection[1]);
        let patternName = currentPattern;
        let patternDesc = "";
        if (currentPattern == "custom") {
          patternName = document.getElementById("customPattern").value;
          if (patternName.trim().length == 0) {
            console.log("Name for pattern missing.");
            return;
          }
        }
        patternDesc = document.getElementById("customPatternDesc").value;
        var pattern = {
          patternName: patternName,
          patternDesc: patternDesc,
          patternStart: start,
          patternEnd: end,
          duration: end - start,
          eventCount: currentEventSelection.length,
          patternId: detectedPatterns.length,
        };
        console.log(pattern);
        // Converting the object to a JSON string
        var jsonString = JSON.stringify(pattern);

        patternsAsJson.push(pattern);
        //Pattern einzeichnen (mit Position und entsprechender Farbe bei Balken
        //oberhalb von Actionlines (Muster für Vergleiche))
        detectedPatterns.push(pattern);
        console.log("Saved " + patternName + " pattern.");
        //Hier detected Patterns Zeichen update triggern
        drawPatterns();

        document.querySelectorAll("div input").forEach(function (input) {
          input.value = "";
          // Trigger the placeholder to be displayed
          input.blur();
          input.focus();
        });
      });

      function drawPatterns() {
        var removeSelection = d3
          .select("body > div#vis > svg")
          .selectAll("rect#patternbars");

        removeSelection.remove();

        svg
          .selectAll("#whatever")
          .data(detectedPatterns)
          .enter()
          .append("rect")
          .attr("id", "patternbars")
          .attr("x", function (d) {
            return xScale(d.patternStart);
          })
          .attr("y", patternLineLocation)
          .attr("width", (d) => {
            return xScale(d.patternEnd) - xScale(d.patternStart);
          })
          .attr("height", function (d) {
            return patternLineHeight * 0.75;
          })
          .attr("fill", (d) => getPatternColors(d.patternName))
          .attr("stroke", "grey")
          .on("dblclick", function (domElem, pattern) {
            removePattern(domElem, pattern);
          });
      }

      function removePattern(domElem, pattern) {
        patternsAsJson = patternsAsJson.filter(
          (elem) => elem.patternId != pattern.patternId
        );
        detectedPatterns = detectedPatterns.filter(
          (elem) => elem.patternId != pattern.patternId
        );
        d3.select(domElem.target).remove();
      }
      d3.select("#exportButton").on("click", function (d) {
        patternSetName = document.getElementById("patternSetName").value;
        if (patternSetName == "" || patternSetName == "Pattern set name") {
          console.log("Pattern Set Name missing");
        } else {
          console.log({
            patternSetName: patternSetName,
            patterns: patternsAsJson,
          });

          patternsAsJson.forEach((pattern) => {
            pattern.patternSetName = patternSetName;

            //sessionName aus der URL bekommen - again
            var queryStr = window.location.search;
            var params = {};
            var paramPairs = queryStr.substr(1).split("&");
            for (var i = 0; i < paramPairs.length; i++) {
              var parts = paramPairs[i].split("=");
              params[parts[0]] = parts[1];
            }
            pattern.sessionName = params.session;
          });

          saveAsFile(
            patternSetName + ".json",
            "data/patternSets",
            JSON.stringify(patternsAsJson, null, "\t")
          );
        }
      });
    }
    function saveAsFile(filename, mime, data) {
      const blob = new Blob([data], { type: mime });
      if (window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
      } else {
        const elem = window.document.createElement("a");
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;
        document.body.appendChild(elem);
        elem.click();
        document.body.removeChild(elem);
      }
    }

    main();
  </script>
</body>
